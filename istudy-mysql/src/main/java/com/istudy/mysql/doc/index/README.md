## mysql高可用
    mysql主从备份+keepalived自动切换
    如果在项目中主mysql挂了，我们是要手动切换msyql吗，这样会比较麻烦的，而且这段时间项目是不能用的。这里用keepalived实现IP的vip漂移，
    keepalived就是一个软件，在主mysql和从mysql上面都安装后，会有一个虚拟IP在其中的一台服务器上面，
    如果这台服务器宕机了，这个IP就会出现在另一台服务器上面，这是keepalived的功能，能够判断是否可用和权重大小，
    然后自动漂移IP，这个IP是虚拟IP，我们可以自己随意设置，不过要跟主、从mysql的IP在同一个网段，
    云服务器好像需要再设置下默认是关闭的，如果是主机是可以直接用的。

## 存储引擎
### 存储引擎概述
    与其他数据库例如Oracle和SQL Server等数据库中只有一种存储引擎不同的是，
    MySQL有一个被称为“Pluggable Storage Engine Architecture”(可替换存储引擎架构)的特性，
    也就意味着MySQL数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，
    用户也可以根据自己的需要编写自己的存储引擎。MySQL数据库在实际的工作中其实分为了语句分析层和存储引擎层，
    其中语句分析层就主要负责与客户端完成连接并且事先分析出SQL语句的内容和功能，而存储引擎层则主要负责接收来自语句
    分析层的分析结果，完成相应的数据输入输出和文件操作。简而言之，就是如何存储数据、如何为存储的数据建立索引和如何更新、
    查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。

### 存储引擎种类
    MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务
    InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢
    
### 总结
    InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），
    要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，
    因为支持事务的提交（commit）和回滚（rollback）。
    
    MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。
    如果应用的完整性、并发性要求比较低，也可以使用。
    
    注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。
    这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。 

## 索引结构(方法、算法)
    在mysql中常用两种索引结构(算法)BTree和Hash，两种算法检索方式不一样，对查询的作用也不一样。
    
    索引的目的：提高查询效率
    原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，
    也就是我们总是通过同一种查找方式来锁定数据。
    
    数据结构：B+树

### Hash
    Hash索引的底层实现是由Hash表来实现的，非常适合以key-value的形式查询，也就是单个key查询，或者说是等值查询。
    其结构如下所示：
    从上面结构可以看出，Hash索引可以比较方便的提供等值查询的场景,由于是一次定位数据，不像BTree索引需要从根节点到枝节点，
    最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。但是对于范围查询的话，就需要进行全表扫描了。
    但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端：
        Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。
        联合索引中，Hash索引不能利用部分索引键查询。 对于联合索引中的多个列，Hash是要么全部使用，
        要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，
        Hash索引无法被利用。
        
        Hash索引无法避免数据的排序操作 由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并
        不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。
        
        Hash索引任何时候都不能避免表扫描 Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的
        行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，
        也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。
        
        Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 对于选择性比较低的索引键，如果创建Hash索引，
        那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，
        而造成整体性能底下。

### B+Tree
    B+Tree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，
    而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，
    例如：* select * from user where name like 'jack%'; select * from user where name like 'jac%k%'; 
    如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like '%jack'; 
    select * from user where name like simply_name;
    
## 思考
    1.为什么Mysql不选择Hash索引？(Hash索引的优势是精确查找的话，速度会更快，为什么不选择Hash索引)
        1.Hash索引不适合范围查找，而B+树特别适合范围查找（特别是聚簇索引的时候）
        2.Hash索引每次查询要加载所有的索引数据到内存当中，而B+树只需要根据匹配规则选择对应的叶子数据加载即可
        3.另外B+树引入了缓存机制和数据页技术来提升性能（不过理论上来说，这两个特性Hash索引也可以实现）

    2.索引为什么会加快查询速度
        首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，
        遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，
        大大减少遍历匹配的行数，所以能明显增加查询的速度。 
   
# select count(1)和select count(*)的区别
## select count(1) from 表a //查询时会对常数列进行统计行数
## select count(*) from 表a //查询时会找表a中最短的列进行统计行数

    因为使用count(*)查询会有一个找寻最短列的过程，从效率上讲会慢一些，虽然不明显，但是
    一般我们使用count(1)查询就可以了，查询结果是一样的

### 为什么最左匹配
    是因为mysql创建联合索引时，首先会对最左边字段排序，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。
    所以联合索引最左列是绝对有序的，其他字段无序。
    举个例子：可以把联合索引看成“电话簿”，姓名作为联合索引，姓是第一列，名是第二列，当查找人名时，是先确定这个人姓再根据名确定人。只有名没有姓就查不到。 
